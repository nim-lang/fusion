#+author: haxscramper
#+property: header-args:nim :imports macros
#+PROPERTY: header-args :eval no-export :cache no :exports both
#+title: Getting started with nim macros using pattern matching


* NOTE: WIP

Nim macros are one of the most powerful and parts of the language, but
they might seem a little intimidating for newcomers, especially when
it comes to implementing macro for solving particular problem at hand.

This article gives an example on how one can easily create relatively
complex macro using new pattern matching library.

We will be creating macro for dataflow programming, with support for
some operatings in the ~std/sequtils~ module (map/filter/each). The
macro won't be covering all possible combinations and use cases as it
would make implementation notably more complicated.


# this is not the best example, but I just don't have any good ideas
# right now

First of, when writing macro, it is very useful to just write DSL code
(as if you already had macro) and what you expect it to generate. In
our case input code would look like this:

#+caption: Macro example
#+begin_src nim
  flow lines("/etc/passwd"):
    map[_, seq[string]]:
      it.split(":")
    keepIf:
      it.len > 1 and
      it.matches [_.startsWith("systemd"), .._]
    each:
      echo it
#+end_src

And will generate this loop

#+caption: Generated code
#+begin_src nim
  for it in lines("/etc/passwd"):
    block:
      let it = it.split(":")
      if it.len > 1 and it.matches[_.startsWith("systemd"), .._]:
        block:
          echo it
#+end_src

Now the question is - how to transform first into second? We will
start by first looking at the output for ~dumpTree~ on ~flow~ macro:

#+begin_src nim
dumpTree:
  flow lines("/etc/passwd"):
    map[_, seq[string]]:
      it.split(":")
#+end_src

#+begin_src nim -n -r
StmtList
  Command
    Ident "flow" (ref:1)
    Call (ref:2)
      Ident "lines"
      StrLit "/etc/passwd"
    StmtList
      Call
        BracketExpr
          Ident "map"
          Ident "_"
          BracketExpr
            Ident "seq"
            Ident "string"
        StmtList
          Call
            DotExpr
              Ident "it"
              Ident "split"
            StrLit ":"
#+end_src
I admit this load of text might seem a little indimidating at first,
but in the end it can be taken apart quite easily (and that is exactly
what we will be doing). First, on line [[(1)]] we see the ~flow~
identifier - this is a start of our macro. Then ([[(2)]]) is a
~lines("/etc/passwd")~ argument.


I usually try to introduce some kind of intermediate representation
for DSL in order to make things more organized and decouple parsing
stage from code generation. This might make implementation a little
longer, but more extensible and robust.


-----

Now, after we have good understanding of what exactly we want to do -
the question is 'how?'. That's where ~fusion/matching~ comes
particularly handy - we already identifier all patterns, and now it is
only matter of writing this down in code.

Without pattern matching you'd be left with long series of repeating
~[0][0][0]~ and ~if kind == nnkBracketExpr~ in order to retrieve parts
from DSL and validate input.

#+begin_src nim
dumpTree:
  map [a]:
    body
#+end_src

#+RESULTS:
: StmtList
:   Command
:     Ident "map"
:     Bracket
:       Ident "a"
:     StmtList
:       Ident "body"

#+begin_src nim
dumpTree:
  map[a]:
    body
#+end_src

#+RESULTS:
: StmtList
:   Call
:     BracketExpr
:       Ident "map"
:       Ident "a"
:     StmtList
:       Ident "body"


#+begin_src nim
dumpTree:
  map:
    body
#+end_src

#+RESULTS:
: StmtList
:   Call
:     Ident "map"
:     StmtList
:       Ident "body"

# I don't really like phrasing, so need to rework this part.
Stepping aside from ~flow~ macro itself, let's familliarlize yourself
with new pattern matching DSL.

We will be focusing on parts that are relevant to our task - for more
details you can read <link to documentation>.

When writing nim macros you are mostly dealing with [[https://nim-lang.org/docs/macros.html#the-ast-in-nim][NimNode]] objects -
first to process input AST, and then generate new code back. AST is
comprised of [[https://nim-lang.org/docs/manual.html#types-object-variants][case objects]]. Usually, first part of the macro involves
lots of checks for correct node kind, followed by iteration over
subnodes to extract input data. Pattern matching simplifies this,
allowing to directly write expected patterns for ast, with syntax
closely matching that of ~dumpTree~.

For example - if we have code like ~map[string]~ it has following tree
representation:

#+begin_src nim
dumpTree:
  map[string]
#+end_src nim

And can be matched using following pattern:

#+begin_src
body.matches:
  BracketExpr[@head, @typeParam]
#+end_src


Notice similarity between AST and pattern for matching - each node
has ~kind~ field, which describes what kind of node this is. In this
case we are interested in first and second subnodes of the ~BracketExpr~
node - flow stage kind and type parameter respectively.


Note that ~map [string]~ and ~map[string]~ parsed differently - first
one is handled as one-element array passed to ~map~ function argument,
and second is bracket expression (like accessing element of the
array). This difference is caused by [[https://nim-lang.org/docs/manual.html#procedures-method-call-syntax][method call syntax]] and usually
makes programming DSL a little harder - you need to check for both
alternatives, remember which index each capture should be in etc.

#+begin_src nim
dumpTree:
  map[string]
  map [string]
#+end_src

With pattern matching though it becomes quite easy to do - adding
second alternnative to match will be enough.

#+begin_src
body.matches:
  BracketExpr[@head, @typeParam] |
  Command[@head, Bracket[@typeParam]]
#+end_src

It should also be possible to omit type parameters from DSL entirely -
they are quite nice and would allow for better type checking, but
could become quite annoying to write. So, we should also expect
someone to just write ~map~ - without any type qualifications. To
handle this case we add third alternative for pattern -

# and pray to god that shit does not blow up when I actually shove
# this in pattern matching DSL itself.

#+begin_src
body.matches:
  BracketExpr[@head, @typeParam] |
  Command[@head, Bracket[@typeParam]] |
  @head is Ident()
#+end_src

This brings one important change ~typeParam~ capture is no longer
~NimNode~ - type has changed to ~Option[NimNode]~, because not all
alternatives have this variable. ~head~ is still a ~NimNode~ just as
before - all possible alternatives contain this variable, so it would
be set if input matches.

-----------


After we are familliar a little with pattern matching DSL, let's turn
back to ~flow~ macro. Out first stage would be processing of all input
into ~FlowStage~. We already have a way to extract data from input
ast - using pattern matching.


#+begin_src nim
macro flow(arg, body: untyped): untyped =
  var stages: seq[FlowStage]
  for elem in body:
    if elem.matches(
        Call[BracketExpr[@ident, opt @outType], @body] |
        # `map[string]:`
        Command[@ident is Ident(), Bracket [@outType], @body] |
        # `map [string]:`
        Call[@ident is Ident(), @body]
        # just `map:`, without type argument
      ):
        stages.add FlowStage(
          kind: identToKind(ident),
          outputType: outType,
          body: body
        )
#+end_src


After that, we have all necessary information for constructing
<things>. If last stage is not ~each~ - e.g. there is a return value
after each iteration, we need to determine type of the result sequence
and then append to it on each iteration.

#+begin_src nim
  if stages[^1].kind notin {fskEach}:
    # If last stage has return type (not `each`) then we need to
    # accumulate results in temporary variable.
    result = quote do:
      var `resId`: seq[#[ Type of the expression ]#]

      for it0 {.inject.} in `arg`:
        `resId`.add #[ Expression to evaluate]#

      `resId`
  else:
    # Otherwise just iterate each element
    result = quote do:
      for it0 {.inject.} in `arg`:
        #[ Expression to evaluate ]#
#+end_src

Each stage of the dataflow has a type, and potentially defines
variables. In addition to that - each stage uses special variable
~it~ - that has to be injected separately for each stage *but* at the
same time it is used for commulicating values between stages.

#+begin_src nim
flow [1,2,3]:
  map:
    it * 2
  map:
    $it
#+end_src

is equivalent to

#+begin_src nim
var res: seq[#[ Type of the expression ]#]

for it in [1, 2, 3]:
  let it = it * 2
  let it = $it
  res.add it

res
#+end_src

As you can clearly see, such code would not even compile due to
redefinition errors. There are two possible ways to solve this
problem - kind of obvious, and not-all-that-obvious. Let's start with
the first one - since each variable can be redefined in the new scope
we can just do

#+begin_src nim
for it in [1, 2, 3]:
  block:
    let it = it * 2
    block:
      let it = $it
      echo "Add result - ", it

#+end_src

#+RESULTS:
: Add result - 2
: Add result - 4
: Add result - 6

And it would compile and work perfectly fine. But now we have a
problem of getting type of the expression itself - everything is fine
as long as you only use ~map~ - after all ~block:~ is an expression,
and we can have something like

#+begin_src nim
  echo typeof((block:
                 let it = 1
                 block:
                   let it = it * 2
                   block: $it))
#+end_src

#+RESULTS:
: string

Not the pretties code in the world, by all means - but it will become
even worse when we have to deal with ~filter~, ~each~, injected
variables and iterators.

Second alternative is to use declare proc with ~auto~ return variable
and assign result of the expression to it.

#+begin_src nim
proc hello[T](a: T): auto =
  for c in "ee":
    result = (12, "som", "ee", a)

echo typeof hello[int]
#+end_src

#+RESULTS:
: proc (a: int): (int, string, string, int){.noSideEffect, gcsafe, locks: 0.}


-----

Second example of ~fusion/matching~ usage shows how to write custom
pattern matching macros that use the same DSL. In particular we will
be reimplementing rust-style macro rewriting, with ~() => {}~.


* COMMENT todo list

- [ ] Check if ~makeTree~ creates correct backtraces / ~error~
  information. I don't really like shoving ~{.line: .}~ everywhere,
  even though it works in most cases.
- [ ] Implement rewriting using ~=>~ as example macro
