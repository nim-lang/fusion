<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>src/fusion/matching</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="../../nimdoc.out.css?v=2.1.1">

<!-- JS -->
<script type="text/javascript" src="../../dochack.js?v=2.1.1"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">src/fusion/matching</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a id="indexLink" href="../../theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" oninput="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="quick-reference_toc" href="#quick-reference">Quick reference</a></li>
<li><a class="reference" id="supported-match-elements_toc" href="#supported-match-elements">Supported match elements</a></li>
<li><a class="reference" id="element-access_toc" href="#element-access">Element access</a></li>
<li><a class="reference" id="checks_toc" href="#checks">Checks</a></li>
<ul class="simple"><li><a class="reference" id="checks-examples_toc" href="#checks-examples">Examples</a></li>
</ul><li><a class="reference" id="variable-binding_toc" href="#variable-binding">Variable binding</a></li>
<ul class="simple"><li><a class="reference" id="variable-binding-bind-order_toc" href="#variable-binding-bind-order">Bind order</a></li>
<li><a class="reference" id="variable-binding-bind-variable-type_toc" href="#variable-binding-bind-variable-type">Bind variable type</a></li>
</ul><li><a class="reference" id="matching-different-things_toc" href="#matching-different-things">Matching different things</a></li>
<ul class="simple"><li><a class="reference" id="matching-different-things-sequence-matching_toc" href="#matching-different-things-sequence-matching">Sequence matching</a></li>
<ul class="simple"><li><a class="reference" id="sequence-matching-use-examples_toc" href="#sequence-matching-use-examples">Use examples</a></li>
</ul><li><a class="reference" id="matching-different-things-tuple-matching_toc" href="#matching-different-things-tuple-matching">Tuple matching</a></li>
<li><a class="reference" id="matching-different-things-object-matching_toc" href="#matching-different-things-object-matching">Object matching</a></li>
<li><a class="reference" id="matching-different-things-variant-object-matching_toc" href="#matching-different-things-variant-object-matching">Variant object matching</a></li>
<li><a class="reference" id="matching-different-things-custom-unpackers_toc" href="#matching-different-things-custom-unpackers">Custom unpackers</a></li>
<li><a class="reference" id="matching-different-things-predicates-and-infix-operators_toc" href="#matching-different-things-predicates-and-infix-operators">Predicates and infix operators</a></li>
<ul class="simple"><li><a class="reference" id="predicates-and-infix-operators-infix-operators_toc" href="#predicates-and-infix-operators-infix-operators">Infix operators</a></li>
<li><a class="reference" id="predicates-and-infix-operators-custom-predicates_toc" href="#predicates-and-infix-operators-custom-predicates">Custom predicates</a></li>
</ul><li><a class="reference" id="matching-different-things-ref-object-matching_toc" href="#matching-different-things-ref-object-matching">Ref object matching</a></li>
<li><a class="reference" id="matching-different-things-kvminuspairs-matching_toc" href="#matching-different-things-kvminuspairs-matching">KV-pairs matching</a></li>
<li><a class="reference" id="matching-different-things-option-matching_toc" href="#matching-different-things-option-matching">Option matching</a></li>
</ul><li><a class="reference" id="tree-matching_toc" href="#tree-matching">Tree matching</a></li>
<li><a class="reference" id="tree-construction_toc" href="#tree-construction">Tree construction</a></li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#7" id="57">Types</a></summary>
    <ul class="simple simple-toc-section">
      <li><a class="reference" href="#FieldIndex" title="FieldIndex = distinct int">FieldIndex</a></li>
<li><a class="reference" href="#ItemMatchKind" title="ItemMatchKind = enum
  imkInfixEq,               ## Match item using infix operator
  imkSubPattern,            ## Match item by checking it agains subpattern
  imkPredicate               ## Execute custom predicate to determine if element
                             ## matches pattern.">ItemMatchKind</a></li>
<li><a class="reference" href="#KVPair" title="KVPair = object">KVPair</a></li>
<li><a class="reference" href="#Match" title="Match = ref object
  bindVar*: Option[NimNode]  ## Bound variable (if any)
  declNode*: NimNode         ## Original declaration of match
  isOptional*: bool
  fallback*: Option[NimNode] ## Default value in case match fails
  case kind*: MatchKind
  of kItem:
    case
    of imkInfixEq:
      infix*: string         ## Infix operator used for comparison
      rhsNode*: NimNode      ## Rhs expression to compare against
      isPlaceholder*: bool   ## Always true? `_` pattern is an
                             ## infix expression with `isPlaceholder` equal to true
    of imkSubPattern:
      rhsPattern*: Match     ## SubPattern to compare value against
    of imkPredicate:
      isCall*: bool          ## Predicate is a call expression
                             ## (`@val.matches()`) or a free-standing expression
                             ## (`@val(it.len &lt; 100)`)
      predBody*: NimNode     ## Body of the expression
  of kAlt:
    altElements*: seq[Match] ## Alternatives for matching
  of kSeq:
    seqElements*: seq[SeqStructure] ## Sequence subpatterns
  of kTuple:
    tupleElements*: seq[Match] ## Tuple elements
  of kPairs:
    pairElements*: seq[KVPair]
    nocheck*: bool
  of kSet:
    setElements*: seq[Match]
  of kObject:
    kindCall*: Option[NimNode] ## Optional node with kind
                               ## expression pattern (see `hasKind`)
    isRefKind*: bool
    fieldElements*: seq[tuple[name: string, pattern: Match]]
    kvMatches*: Option[Match] ## Optional key-value matches for
                              ## expressions like `JObject({&quot;key&quot;: @val})`
    seqMatches*: Option[Match] ## Optional indexed matches for
                               ## subelement access using `Infix([@op, @lhs, @rhs])` pattern.">Match</a></li>
<li><a class="reference" href="#MatchError" title="MatchError = ref object of CatchableError">MatchError</a></li>
<li><a class="reference" href="#MatchKind" title="MatchKind = enum
  kItem,                    ## Match single element
  kSeq,                     ## Match sequence of elements
  kTuple,                   ## Mach tuple (anonymous or named)
  kPairs,                   ## Match key-value pairs
  kObject,                  ## Match object, named tuple or object-like value
  kSet,                     ## Match set of elements
  kAlt                       ## Ordered choice - mactch any of patterns.">MatchKind</a></li>
<li><a class="reference" href="#SeqKeyword" title="SeqKeyword = enum
  lkAny = &quot;any&quot;,            ## Any element from seq
  lkAll = &quot;all&quot;,            ## All elements from seq
  lkNone = &quot;none&quot;,          ## None of the elements from seq
  lkOpt = &quot;opt&quot;,            ## Optionaly match element in seq
  lkUntil = &quot;until&quot;,        ## All elements until
  lkPref = &quot;pref&quot;,          ## All elements while
  lkPos,                    ## Exact position
  lkSlice,                  ## Subrange slice
  lkTrail                    ## Variadic placeholder `.._`">SeqKeyword</a></li>
<li><a class="reference" href="#SeqStructure" title="SeqStructure = object
  ## Original declaration of the node
  bindVar*: Option[NimNode]  ## Optional bound variable
  pattern*: Match            ## Patterh for element matching
  case kind*: SeqKeyword
  of lkSlice:
    slice*: NimNode
  else:
    nil">SeqStructure</a></li>
<li><a class="reference" href="#VarKind" title="VarKind = enum
  vkRegular,                ## Regular variable, assigned once
  vkSequence, vkOption, vkSet, vkAlt">VarKind</a></li>
<li><a class="reference" href="#VarSpec" title="VarSpec = object
  decl*: NimNode             ## First time variable has been declared
  case varKind*: VarKind     ## Type of the variable
  of vkAlt:
    prefixMap*: Table[Path, AltSpec]
  else:
    nil
  typePath*: Path            ## Whole path for expression that can be used to
                             ## determine type of the variable.
  foundCount*: int           ## Number of variable occurencies in expression">VarSpec</a></li>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#10" id="60">Consts</a></summary>
    <ul class="simple simple-toc-section">
      <li><a class="reference" href="#nnkFloatKinds" title="nnkFloatKinds = {nnkFloatLit..nnkFloat128Lit}">nnkFloatKinds</a></li>
<li><a class="reference" href="#nnkIdentKinds" title="nnkIdentKinds = {nnkIdent, nnkSym, nnkOpenSymChoice}">nnkIdentKinds</a></li>
<li><a class="reference" href="#nnkIntKinds" title="nnkIntKinds = {nnkCharLit..nnkUInt64Lit}">nnkIntKinds</a></li>
<li><a class="reference" href="#nnkStrKinds" title="nnkStrKinds = {nnkStrLit..nnkTripleStrLit}">nnkStrKinds</a></li>
<li><a class="reference" href="#nnkTokenKinds" title="nnkTokenKinds = {nnkEmpty..nnkSym, nnkCharLit..nnkTripleStrLit, nnkOpenSymChoice}">nnkTokenKinds</a></li>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#12" id="62">Procs</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">$
  <li><a class="reference" href="#%24%2CKVPair" title="`$`(kvp: KVPair): string">`$`(kvp: KVPair): string</a></li>
<li><a class="reference" href="#%24%2CMatch" title="`$`(match: Match): string">`$`(match: Match): string</a></li>
<li><a class="reference" href="#%24%2CPath" title="`$`(path: Path): string">`$`(path: Path): string</a></li>
<li><a class="reference" href="#%24%2CSeqStructure" title="`$`(ss: SeqStructure): string">`$`(ss: SeqStructure): string</a></li>

</ul>
<ul class="simple nested-toc-section">==
  <li><a class="reference" href="#%3D%3D%2CFieldIndex%2CSomeInteger" title="`==`(idx: FieldIndex; i: SomeInteger): bool">`==`(idx: FieldIndex; i: SomeInteger): bool</a></li>

</ul>
<ul class="simple nested-toc-section">getKindNames
  <li><a class="reference" href="#getKindNames%2CNimNode" title="getKindNames(head: NimNode): (string, seq[string])">getKindNames(head: NimNode): (string, seq[string])</a></li>

</ul>
<ul class="simple nested-toc-section">kind=
  <li><a class="reference" href="#kind%3D%2CNimNode%2CNimNodeKind" title="kind=(node: var NimNode; kind: NimNodeKind)">kind=(node: var NimNode; kind: NimNodeKind)</a></li>

</ul>
<ul class="simple nested-toc-section">makeMatchExpr
  <li><a class="reference" href="#makeMatchExpr%2CMatch%2CNimNode%2Cbool%2CNimNode" title="makeMatchExpr(m: Match; mainExpr: NimNode; doRaise: bool;
              originalMainExpr: NimNode): tuple[expr: NimNode, vtable: VarTable,
    mixident: seq[string]]">makeMatchExpr(m: Match; mainExpr: NimNode; doRaise: bool;
              originalMainExpr: NimNode): tuple[expr: NimNode, vtable: VarTable,
    mixident: seq[string]]</a></li>

</ul>
<ul class="simple nested-toc-section">parseMatchExpr
  <li><a class="reference" href="#parseMatchExpr%2CNimNode" title="parseMatchExpr(n: NimNode): Match">parseMatchExpr(n: NimNode): Match</a></li>

</ul>
<ul class="simple nested-toc-section">str
  <li><a class="reference" href="#str%2CNimNode" title="str(node: NimNode): string">str(node: NimNode): string</a></li>

</ul>
<ul class="simple nested-toc-section">str=
  <li><a class="reference" href="#str%3D%2CNimNode%2Cstring" title="str=(node: var NimNode; val: string)">str=(node: var NimNode; val: string)</a></li>

</ul>
<ul class="simple nested-toc-section">toAccs
  <li><a class="reference" href="#toAccs%2CPath%2CNimNode%2Cbool" title="toAccs(path: Path; name: NimNode; pathForType: bool): NimNode">toAccs(path: Path; name: NimNode; pathForType: bool): NimNode</a></li>

</ul>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#17" id="67">Macros</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">assertMatch
  <li><a class="reference" href="#assertMatch.m%2Cuntyped%2Cuntyped" title="assertMatch(input, pattern: untyped): untyped">assertMatch(input, pattern: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">case
  <li><a class="reference" href="#case.m%2Cuntyped" title="`case`(n: untyped): untyped">`case`(n: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">expand
  <li><a class="reference" href="#expand.m%2Ctyped" title="expand(body: typed): untyped">expand(body: typed): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">hasKindImpl
  <li><a class="reference" href="#hasKindImpl.m%2Ctyped%2Cuntyped" title="hasKindImpl(head: typed; kind: untyped): untyped">hasKindImpl(head: typed; kind: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">matches
  <li><a class="reference" href="#matches.m%2Cuntyped%2Cuntyped" title="matches(input, pattern: untyped): untyped">matches(input, pattern: untyped): untyped</a></li>

</ul>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#18" id="68">Templates</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">:=
  <li><a class="reference" href="#%3A%3D.t%2Cuntyped%2Cuntyped" title="`:=`(lhs, rhs: untyped): untyped">`:=`(lhs, rhs: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">?=
  <li><a class="reference" href="#%3F%3D.t%2Cuntyped%2Cuntyped" title="`?=`(lhs, rhs: untyped): untyped">`?=`(lhs, rhs: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">[]
  <li><a class="reference" href="#%5B%5D.t%2C%2Cstatic%5BFieldIndex%5D" title="`[]`(t: tuple; idx: static[FieldIndex]): untyped">`[]`(t: tuple; idx: static[FieldIndex]): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">hasKind
  <li><a class="reference" href="#hasKind.t%2Cuntyped%2Cuntyped" title="hasKind(head, kindExpr: untyped): untyped">hasKind(head, kindExpr: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">makeTree
  <li><a class="reference" href="#makeTree.t%2Ctyped%2Cuntyped" title="makeTree(T: typed; pattern: untyped): untyped">makeTree(T: typed; pattern: untyped): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">varOfIteration
  <li><a class="reference" href="#varOfIteration.t%2Cuntyped" title="varOfIteration(arg: untyped): untyped">varOfIteration(arg: untyped): untyped</a></li>

</ul>

    </ul>
  </details>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc">
<p><strong class="examples_text">Example:</strong></p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">src</span><span class="Operator">/</span><span class="Identifier">fusion</span><span class="Operator">/</span><span class="Identifier">matching</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;caseStmtMacros&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">case</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span>

  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Match failed&quot;</span></pre><blockquote><p>
"you can probably make a macro for that" -- Rika, 22-09-2020 10:41:51
</p></blockquote><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>haxscramper</td></tr>
</tbody></table><p>This module implements pattern matching for objects, tuples, sequences, key-value pairs, case and derived objects. DSL can also be used to create object trees (AST).</p>

<h1><a class="toc-backref" id="quick-reference" href="#quick-reference">Quick reference</a></h1><table border="1" class="docutils"><tr><th>Example</th><th>Explanation</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td>Field <tt class="docutils literal"><span class="pre">fld</span></tt> into variable <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">Kind()</span></tt></td><td>Object with <tt class="docutils literal"><span class="pre">.kind == Kind()</span></tt> <a class="reference internal" href="#1">1</a></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">of Derived()</span></tt></td><td>Match object of derived type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, _)</span></tt></td><td>First element in tuple in <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, @val)</span></tt></td><td>Tuple with two equal elements</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot; : @val}</span></tt></td><td>Table with &quot;key&quot;, capture into <tt class="docutils literal"><span class="pre">@val</span></tt> <a class="reference internal" href="#2">2</a></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, _]</span></tt></td><td>Sequence with <tt class="docutils literal"><span class="pre">len == 2</span></tt> <a class="reference internal" href="#3">3</a></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, .._]</span></tt></td><td>At least one element</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, all @val]</span></tt></td><td>All elements starting from index <tt class="docutils literal"><span class="pre">1</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == &quot;2&quot;, .._]</span></tt></td><td>Capture all elements <em>until</em> first <tt class="docutils literal"><span class="pre">&quot;2&quot;</span></tt> <a class="reference internal" href="#4">4</a></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == 1, @val]</span></tt></td><td>All <em>including</em> first match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @val == 12]</span></tt></td><td>All elements are <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[some @val == 12]</span></tt></td><td>At least <em>one</em> is <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture all matching into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
</table><ul class="simple"><li><a class="reference internal" href="#1">1</a> Kind fields can use shorted enum names - both <tt class="docutils literal"><span class="pre">nnkStrLit</span></tt> and <tt class="docutils literal"><span class="pre">StrLit</span></tt> will work (prefix <tt class="docutils literal"><span class="pre">nnk</span></tt> can be omitted)</li>
<li><a class="reference internal" href="#2">2</a> Or any object with <tt class="docutils literal"><span class="pre">contains</span></tt> and <tt class="docutils literal"><span class="pre">[]</span></tt> defined (for necessary types)</li>
<li><a class="reference internal" href="#3">3</a> Or any object with <tt class="docutils literal"><span class="pre">len</span></tt> proc or field</li>
<li><a class="reference internal" href="#4">4</a> Note that sequence must match <em>fully</em> and it is necessary to have <tt class="docutils literal"><span class="pre">.._</span></tt> at the end in order to accept sequences of arbitrary length.</li>
</ul>

<h1><a class="toc-backref" id="supported-match-elements" href="#supported-match-elements">Supported match elements</a></h1><ul class="simple"><li><em>seqs</em> - matched using <tt class="docutils literal"><span class="pre">[Patt1(), Patt2(), ..]</span></tt>. Must have <tt class="docutils literal"><span class="pre">len(): int</span></tt> and <tt class="docutils literal"><span class="pre">iterator items(): T</span></tt> defined.</li>
<li><em>tuples</em> - matched using <tt class="docutils literal"><span class="pre">(Patt1(), Patt2(), ..)</span></tt>.</li>
<li><em>pairable</em> - matched using <tt class="docutils literal"><span class="pre">{Key: Patt()}</span></tt>. Must have <tt class="docutils literal"><span class="pre">[Key]: T</span></tt> defined. <tt class="docutils literal"><span class="pre">Key</span></tt> is not a pattern - search for whole collection won't be performed.</li>
<li><em>set</em> - matched using <tt class="docutils literal"><span class="pre">{Val1, Val2, .._}</span></tt>. Must have <tt class="docutils literal"><span class="pre">contains</span></tt> defined. If variable is captured then <tt class="docutils literal"><span class="pre">Val1</span></tt> must be comparable and collection should also implement <tt class="docutils literal"><span class="pre">items</span></tt> and <tt class="docutils literal"><span class="pre">incl</span></tt>.</li>
<li><em>object</em> - matched using <tt class="docutils literal"><span class="pre">(field: Val)</span></tt>. Case objects are matched using <tt class="docutils literal"><span class="pre">Kind(field: Val)</span></tt>. If you want to check agains multiple values for kind field <tt class="docutils literal"><span class="pre">(kind: in SomeSetOfKinds)</span></tt></li>
</ul>

<h1><a class="toc-backref" id="element-access" href="#element-access">Element access</a></h1><p>To determine whether particular object matches pattern <em>access path</em> is generated - sequence of fields and <tt class="docutils literal"><span class="pre">[]</span></tt> operators that you would normally write by hand, like <tt class="docutils literal"><span class="pre">fld.subfield[&quot;value&quot;].len</span></tt>. Due to support for <a class="reference external" href="https://nim-lang.org/docs/manual.html#procedures-method-call-syntax">method call syntax</a> there is no difference between field access and proc call, so things like <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">:</span> <span class="Operator">&lt;</span> <span class="DecNumber">12</span><span class="Punctuation">)</span></span></tt> also work as expected.</p>
<p><tt class="docutils literal"><span class="pre">(fld: &quot;3&quot;)</span></tt> Match field <tt class="docutils literal"><span class="pre">fld</span></tt> against <tt class="docutils literal"><span class="pre">&quot;3&quot;</span></tt>. Generated access is <tt class="docutils literal"><span class="pre">expr.fld == &quot;3&quot;</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">[&quot;2&quot;]</span></tt> Match first element of expression agains patt. Generate acess <tt class="docutils literal"><span class="pre">expr[pos] == &quot;2&quot;</span></tt>, where <tt class="docutils literal"><span class="pre">pos</span></tt> is an integer index for current position in sequence.</p>
<p><tt class="docutils literal"><span class="pre">(&quot;2&quot;)</span></tt> For each field generate access using <tt class="docutils literal"><span class="pre">[1]</span></tt></p>
<p><tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt> First check <tt class="docutils literal"><span class="pre">&quot;key&quot; in expr</span></tt> and then <tt class="docutils literal"><span class="pre">expr[&quot;key&quot;] == &quot;val&quot;</span></tt>. No exception on missing keys, just fail match.</p>
<p>It is possible to have mixed assess for objects. Mixed object access via <tt class="docutils literal"><span class="pre">(gg: _, [], {})</span></tt> creates the same code for checking. E.g <tt class="docutils literal"><span class="pre">([_])</span></tt> is the same as <tt class="docutils literal"><span class="pre">[_]</span></tt>, <tt class="docutils literal"><span class="pre">({&quot;key&quot;: &quot;val&quot;})</span></tt> and is identical to just <tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt>. You can also call functions and check their values (like <tt class="docutils literal"><span class="pre">(len: _(it &lt; 10))</span></tt> or <tt class="docutils literal"><span class="pre">(len: in {0 .. 10})</span></tt>) to check for sequence length.</p>

<h1><a class="toc-backref" id="checks" href="#checks">Checks</a></h1><ul class="simple"><li>Any operators with exception of <tt class="docutils literal"><span class="pre">is</span></tt> (subpattern) and <tt class="docutils literal"><span class="pre">of</span></tt> (derived object subpattern) is considered final comparison and just pasted as-is into generated pattern match code. E.g. <tt class="docutils literal"><span class="pre">fld: in {2,3,4}</span></tt> will generate <tt class="docutils literal"><span class="pre">expr.fld in {2,3,4}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: Patt())</span></tt> - check if <tt class="docutils literal"><span class="pre">expr.fld</span></tt> matches pattern <tt class="docutils literal"><span class="pre">Patt()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: _.matchesPredicate())</span></tt> - if call to <tt class="docutils literal"><span class="pre">matchesPredicate(expr.fld)</span></tt> evaluates to true.</li>
</ul>
<p>Notation: <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> refers to any possible combination of checks. For example</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">fld: in {1,2,3}</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">in {1,2,3}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">[_]</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">_</span></tt></li>
<li><tt class="docutils literal"><span class="pre">fld: Patt()</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">Patt()</span></tt></li>
</ul>

<h2><a class="toc-backref" id="checks-examples" href="#checks-examples">Examples</a></h2><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: 12)</span></tt> If rhs for key-value pair is integer, string or identifier then <tt class="docutils literal"><span class="pre">==</span></tt> comparison will be generated.</li>
<li><tt class="docutils literal"><span class="pre">(fld: == ident(&quot;33&quot;))</span></tt> if rhs is a prefix of <tt class="docutils literal"><span class="pre">==</span></tt> then <tt class="docutils literal"><span class="pre">==</span></tt> will be generated. Any for of prefix operator will be converted to <tt class="docutils literal"><span class="pre">expr.fld &lt;op&gt; &lt;rhs&gt;</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">(fld: in {1, 3, 3})</span></tt> or <tt class="docutils literal"><span class="pre">(fld: in Anything)</span></tt> creates <tt class="docutils literal"><span class="pre">fld.expr in Anything</span></tt>. Either <tt class="docutils literal"><span class="pre">in</span></tt> or <tt class="docutils literal"><span class="pre">notin</span></tt> can be used.</li>
</ul>

<h1><a class="toc-backref" id="variable-binding" href="#variable-binding">Variable binding</a></h1><p>Match can be bound to new variable. All variable declarations happen via <tt class="docutils literal"><span class="pre">@varname</span></tt> syntax.</p>
<ul class="simple"><li>To bind element to variable without any additional checks do: <tt class="docutils literal"><span class="pre">(fld: @varname)</span></tt></li>
<li>To bind element with some additional operator checks do:<ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @varname &lt;operator&gt; Value)</span></tt> first perform check using <tt class="docutils literal"><span class="pre">&lt;operator&gt;</span></tt> and then add <tt class="docutils literal"><span class="pre">Value</span></tt> to <tt class="docutils literal"><span class="pre">@varname</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @hello is (&quot;2&quot; | &quot;3&quot;))</span></tt></li>
</ul>
</li>
</ul>
</li>
<li>Predicate checks: <tt class="docutils literal"><span class="pre">fld: @a.matchPredicate()</span></tt></li>
<li>Arbitrary expression: <tt class="docutils literal"><span class="pre">fld: @a(it mod 2 == 0)</span></tt>. If expression has no type it is considered <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
</ul>

<h2><a class="toc-backref" id="variable-binding-bind-order" href="#variable-binding-bind-order">Bind order</a></h2><p>Bind order: if check evaluates to true variable is bound immediately, making it possible to use in other checks. <tt class="docutils literal"><span class="pre">[@head, any @tail != head]</span></tt> is a valid pattern. First match <tt class="docutils literal"><span class="pre">head</span></tt> and then any number of <tt class="docutils literal"><span class="pre">@tail</span></tt> elements. Can use <tt class="docutils literal"><span class="pre">any _(if it != head: tail.add it)</span></tt> and declare <tt class="docutils literal"><span class="pre">tail</span></tt> externally.</p>
<p>Variable is never rebound. After it is bound, then it will have the value of first binding.</p>

<h2><a class="toc-backref" id="variable-binding-bind-variable-type" href="#variable-binding-bind-variable-type">Bind variable type</a></h2><ul class="simple"><li>Any variadics are mapped to sequence</li>
<li>Only once in alternative is option</li>
<li>Explicitly optional is option</li>
<li>Optional with default value is regular value</li>
<li>Variable can be used only once if in alternative</li>
</ul>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Injected variables</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot;: @val}</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr[&quot;key&quot;])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: seq[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: Option[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val or default]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr.fld)</span></tt></td></tr>
</table>
<h1><a class="toc-backref" id="matching-different-things" href="#matching-different-things">Matching different things</a></h1>
<h2><a class="toc-backref" id="matching-different-things-sequence-matching" href="#matching-different-things-sequence-matching">Sequence matching</a></h2><p>Input sequence: <tt class="docutils literal"><span class="pre">[1,2,3,4,5,6,5,6]</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[.._]</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a, .._]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = 1</span></tt></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a, .._]</span></tt></td><td><strong>Error</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &lt; 10)]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = [1..6]</span></tt></td><td>Capture all elements that match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @a == 6, .._]</span></tt></td><td><strong>Ok</strong></td><td>All until first ocurrence of <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a == 6, .._]</span></tt></td><td><strong>Ok</strong> <tt class="docutils literal"><span class="pre">a = []</span></tt></td><td>All leading <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &gt; 100)]</span></tt></td><td><strong>Fail</strong></td><td>No elements <tt class="docutils literal"><span class="pre">&gt; 100</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[none @a(it in {6 .. 10})]</span></tt></td><td><strong>Fail</strong></td><td>There is an element <tt class="docutils literal"><span class="pre">== 6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[0 .. 2 is &lt; 10, .._]</span></tt></td><td><strong>Ok</strong></td><td>First three elements <tt class="docutils literal"><span class="pre">&lt; 10</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[0 .. 2 is &lt; 10]</span></tt></td><td><strong>Fail</strong></td><td>Missing trailing <tt class="docutils literal"><span class="pre">.._</span></tt></td></tr>
</table><p><tt class="docutils literal"><span class="pre">until</span></tt> non-greedy. Match everything until <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt></p>
<pre>- ``until &lt;expr&gt;``: match all until the first element that matches Expr</pre>
<p><tt class="docutils literal"><span class="pre">all</span></tt> greedy. Match everything that matches <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt></p>
<pre>- ``all &lt;expr&gt;``: all elements should match Expr

- ``all @val is &lt;expr&gt;``: capture all elements in ``@val`` if ``&lt;expr&gt;``
  is true for every one of them.</pre>
<p><tt class="docutils literal"><span class="pre">opt</span></tt></p>
<pre>Optional single element match - if sequence contains fewer elements than
necessary element is considered missing. In that case either `default`
fallback (if present) is used as value, or capture is set to `None(T)`.

- ``opt @a``: match optional element and bind it to a

- ``opt @a or &quot;default&quot;``: either match element to a or set a to
  &quot;default&quot;</pre>
<p><tt class="docutils literal"><span class="pre">any</span></tt> greedy. Consume all sequence elements until the end and succeed only if at least one element has matched.</p>
<pre>- ``any @val is &quot;d&quot;``: capture all element that match ``is &quot;d&quot;``</pre>
<p><tt class="docutils literal"><span class="pre">none</span></tt> greedy. Consume all sequence elements until the end and succed only if any element has matched. EE</p>
<p><tt class="docutils literal"><span class="pre">[m .. n @capture]</span></tt> Capture slice of elements from index <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> to <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt></p>
<p>Greedy patterns match until the end of a sequence and cannot be followed by anything else.</p>
<p>For sequence to match is must either be completely matched by all subpatterns or have trailing <tt class="docutils literal"><span class="pre">.._</span></tt> in pattern.</p>
<table border="1" class="docutils"><tr><th>Sequence</th><th>Pattern</th><th>Match result</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt></td><td><tt class="docutils literal"><span class="pre">[1,2]</span></tt> <tt class="docutils literal"><span class="pre">[1, .._]</span></tt> <tt class="docutils literal"><span class="pre">[1,2,_]</span></tt></td><td><strong>Fail</strong> <strong>Ok</strong> <strong>Ok</strong></td></tr>
</table>
<h3><a class="toc-backref" id="sequence-matching-use-examples" href="#sequence-matching-use-examples">Use examples</a></h3><ul class="simple"><li>capture all elements in sequence: <tt class="docutils literal"><span class="pre">[all @elems]</span></tt></li>
<li>get all elements until (not including &quot;d&quot;): <tt class="docutils literal"><span class="pre">[until @a is &quot;d&quot;]</span></tt></li>
<li>All leading &quot;d&quot;: <tt class="docutils literal"><span class="pre">[all @leading is &quot;d&quot;]</span></tt></li>
<li>Match first two elements and ignore the rest <tt class="docutils literal"><span class="pre">[_, _, .._]</span></tt></li>
<li>Match optional third element <tt class="docutils literal"><span class="pre">[_, _, opt @trail]</span></tt></li>
<li>Match third element and if not matched use default value <tt class="docutils literal"><span class="pre">[_, _, opt @trail or &quot;default&quot;]</span></tt></li>
<li>Capture all elements until first separator: <tt class="docutils literal"><span class="pre">[until @leading is &quot;sep&quot;, @middle is &quot;sep&quot;, all @trailing]</span></tt></li>
<li>Extract all conditions from IfStmt: <tt class="docutils literal"><span class="pre">IfStmt([all ElseIf([@cond, _]), .._])</span></tt></li>
</ul>
<p>In addition to working with nested subpatterns it is possible to use pattern matching as simple text scanner, similar to strscans. Main difference is that it allows working on arbitrary sequences, meaning it is possible, for example, to operate on tokens, or as in this example on strings (for the sake of simplicity).</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Identifier">allIs</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">chars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">str</span><span class="Operator">.</span><span class="Identifier">allIt</span><span class="Punctuation">(</span><span class="Identifier">it</span> <span class="Keyword">in</span> <span class="Identifier">chars</span><span class="Punctuation">)</span>

<span class="StringLit">&quot;2019-10-11 school start&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">'</span><span class="Operator">-</span><span class="CharLit">', '</span> <span class="CharLit">'}).assertMatch([</span>
  <span class="Identifier">pref</span> <span class="Operator">@</span><span class="Identifier">dateParts</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">allIs</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">'</span><span class="DecNumber">0'</span> <span class="Operator">..</span> <span class="CharLit">'9'</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
  <span class="Identifier">pref</span> <span class="Identifier">_</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">allIs</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">'</span> <span class="CharLit">'})),</span>
  <span class="Identifier">all</span> <span class="Operator">@</span><span class="Identifier">text</span>
<span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">dateParts</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;2019&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;10&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;11&quot;</span><span class="Punctuation">]</span>
<span class="Identifier">doAssert</span> <span class="Identifier">text</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;school&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;start&quot;</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="matching-different-things-tuple-matching" href="#matching-different-things-tuple-matching">Tuple matching</a></h2><p>Input tuple: <tt class="docutils literal"><span class="pre">(1, 2, &quot;fa&quot;)</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(_, _, _)</span></tt></td><td><strong>Ok</strong></td><td>Match all</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a, @a, _)</span></tt></td><td><strong>Fail</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a is (1 | 2), @a, _)</span></tt></td><td><strong>Fail</strong></td><td><a class="reference internal" href="#1">1</a></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(1, 1 | 2, _)</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
</table><ul class="simple"><li><a class="reference internal" href="#1">1</a> Pattern backtracking is not performed, <tt class="docutils literal"><span class="pre">@a</span></tt> is first bound to <tt class="docutils literal"><span class="pre"><span class="DecNumber">1</span></span></tt>, and in subsequent match attempts pattern fails.</li>
</ul>
<p>Tuple element matches support any regular match expression like <tt class="docutils literal"><span class="pre">@capture</span></tt>, and not different from field matches. You can also use <tt class="docutils literal"><span class="pre">opt @capture or &quot;default&quot;</span></tt> in order to assign fallback value on tuple unpacking.</p>
<pre class="listing"><span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">)</span> <span class="Punctuation">:</span><span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;world&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">11</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="FloatNumber">0.2</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="matching-different-things-object-matching" href="#matching-different-things-object-matching">Object matching</a></h2><p>For matching object fields you can use <tt class="docutils literal"><span class="pre">(fld: value)</span></tt> -</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">fld1</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>

<span class="Keyword">func</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">:</span> <span class="Identifier">Obj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">case</span> <span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">fld1</span><span class="Punctuation">:</span> <span class="Operator">&lt;</span> <span class="Operator">-</span><span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">discard</span>
  
  <span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">:</span> <span class="Operator">&gt;</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Comment"># can use results of function evaluation as fields - same idea as</span>
    <span class="Comment"># method call syntax in regular code.</span>
    <span class="Keyword">discard</span>
  
  <span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">fld1</span><span class="Punctuation">:</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="DecNumber">1</span> <span class="Operator">..</span> <span class="DecNumber">10</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">discard</span>
  
  <span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">fld1</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">capture</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">doAssert</span> <span class="Identifier">capture</span> <span class="Operator">==</span> <span class="DecNumber">0</span></pre><p>For objects with <tt class="docutils literal"><span class="pre">Option[T]</span></tt> fields it is possible to use <tt class="docutils literal"><span class="pre">field: opt @capture or &quot;default&quot;</span></tt> to either get capture value, or set it to fallback expression.</p>

<h2><a class="toc-backref" id="matching-different-things-variant-object-matching" href="#matching-different-things-variant-object-matching">Variant object matching</a></h2><p>Matching on <tt class="docutils literal"><span class="pre">.kind</span></tt> field is a very common operation and has special syntax sugar - <tt class="docutils literal"><span class="pre">ForStmt()</span></tt> is functionally equivalent to <tt class="docutils literal"><span class="pre">(kind: nnkForStmt)</span></tt>, but much more concise.</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">nnk</span></span></tt> pefix can be omitted - in general if your enum field name folows <tt class="docutils literal"><span class="pre"><span class="Identifier">nep1</span></span></tt> naming <a class="reference external" href="https://nim-lang.org/docs/nep1.html#introduction-naming-conventions">conventions</a> (each enum name starts with underscore prefix (common for all enum elements), followed PascalCase enum name.</p>
<p>Input AST</p>
<pre class="listing"><span class="Identifier">ForStmt</span>
  <span class="Identifier">Ident</span> <span class="StringLit">&quot;i&quot;</span>
  <span class="Identifier">Infix</span>
    <span class="Identifier">Ident</span> <span class="StringLit">&quot;..&quot;</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">1</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">10</span>
  <span class="Identifier">StmtList</span>
    <span class="Identifier">Command</span>
      <span class="Identifier">Ident</span> <span class="StringLit">&quot;echo&quot;</span>
      <span class="Identifier">IntLit</span> <span class="DecNumber">12</span></pre><ul class="simple"><li><tt class="docutils literal"><span class="pre">ForStmt([== ident(&quot;i&quot;), .._])</span></tt> Only for loops with <tt class="docutils literal"><span class="pre">i</span></tt> as variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a is Ident(), .._])</span></tt> Capture for loop variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a.isTuple(), .._])</span></tt> for loops in which first subnode satisfies predicate <tt class="docutils literal"><span class="pre">isTuple()</span></tt>. Bind match to <tt class="docutils literal"><span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ForStmt([_, _, (len: in {1 .. 10})])</span></tt> between one to ten statements in the for loop body</li>
<li>Using object name for pattern matching <tt class="docutils literal"><span class="pre">ObjectName()</span></tt> does not produce a hard error, but if <tt class="docutils literal"><span class="pre">.kind</span></tt> field does not need to be checked <tt class="docutils literal"><span class="pre">(fld: &lt;pattern&gt;)</span></tt> will be sufficient.</li>
<li>To check <tt class="docutils literal"><span class="pre">.kind</span></tt> against multiple operators prefix <tt class="docutils literal"><span class="pre">in</span></tt> can be used - <tt class="docutils literal"><span class="pre">(kind: in {nnkForStmt, nnkWhileStmt})</span></tt></li>
</ul>

<h2><a class="toc-backref" id="matching-different-things-custom-unpackers" href="#matching-different-things-custom-unpackers">Custom unpackers</a></h2><p>It is possible to unpack regular object using tuple matcher syntax - in this case overload for <tt class="docutils literal"><span class="pre">[]</span></tt> operator must be provided that accepts <tt class="docutils literal"><span class="pre">static[FieldIndex]</span></tt> argument and returns a field.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Point</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">Point</span><span class="Punctuation">,</span> <span class="Identifier">idx</span><span class="Punctuation">:</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">FieldIndex</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">idx</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">elif</span> <span class="Identifier">idx</span> <span class="Operator">==</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">y</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">static</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Cannot unpack `Point` into three-tuple&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Identifier">point</span> <span class="Operator">=</span> <span class="Identifier">Point</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>

<span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Punctuation">:</span><span class="Operator">=</span> <span class="Identifier">point</span>

<span class="Identifier">assertEq</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="DecNumber">12</span>
<span class="Identifier">assertEq</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="DecNumber">13</span></pre><p>Note <tt class="docutils literal"><span class="pre">auto</span></tt> return type for <tt class="docutils literal"><span class="pre">[]</span></tt> proc - it is necessary if different types of fields might be returned on tuple unpacking, but not mandatory.</p>
<p>If different fields have varying types <tt class="docutils literal"><span class="pre">when</span></tt> <strong>must</strong> and <tt class="docutils literal"><span class="pre">static</span></tt> be used to allow for compile-time code selection.</p>

<h2><a class="toc-backref" id="matching-different-things-predicates-and-infix-operators" href="#matching-different-things-predicates-and-infix-operators">Predicates and infix operators</a></h2>
<h3><a class="toc-backref" id="predicates-and-infix-operators-infix-operators" href="#predicates-and-infix-operators-infix-operators">Infix operators</a></h3><p>By default object fields are either matched using recursive pattern, or compared for equality (when <tt class="docutils literal"><span class="pre">field: &quot;some value&quot;</span></tt> is used). It is also possible to explicitly specify operator, for example using <tt class="docutils literal"><span class="pre">=~</span></tt> from <tt class="docutils literal"><span class="pre">std/pegs</span></tt> module:</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Punctuation">(</span><span class="Identifier">parent</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">:</span> <span class="StringLit">&quot;string&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">parent</span><span class="Operator">.</span><span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Operator">=~</span> <span class="RawData">peg&quot;str{\w+}&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">doAssert</span> <span class="Identifier">matches</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="StringLit">&quot;ing&quot;</span></pre><p>It should be noted that implicitly injected <tt class="docutils literal"><span class="pre">matches</span></tt> variable is also visible in the case branch.</p>

<h3><a class="toc-backref" id="predicates-and-infix-operators-custom-predicates" href="#predicates-and-infix-operators-custom-predicates">Custom predicates</a></h3><p>Matching expressions using custom predicates is also possible. If it is not necessary to capture matched element placeholder <tt class="docutils literal"><span class="pre">_.</span></tt> should be used as a first argument:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">lenEq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">==</span> <span class="Identifier">value</span>

<span class="Keyword">case</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Identifier">_</span><span class="Operator">.</span><span class="Identifier">lenEq</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Comment"># fails</span>
  
  <span class="Keyword">of</span> <span class="Identifier">_</span><span class="Operator">.</span><span class="Identifier">lenEq</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Comment"># matches</span></pre><p>To capture value using predicate placeholder can be replaced with <tt class="docutils literal"><span class="pre">@capture</span></tt> pattern:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">arr</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span><span class="Punctuation">]</span>
<span class="Keyword">discard</span> <span class="Identifier">arr</span><span class="Operator">.</span><span class="Identifier">matches</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="Identifier">any</span> <span class="Operator">@</span><span class="Identifier">capture</span><span class="Operator">.</span><span class="Identifier">lenEq</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
<span class="Identifier">doAssert</span> <span class="Identifier">capture</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="matching-different-things-ref-object-matching" href="#matching-different-things-ref-object-matching">Ref object matching</a></h2><p>It is also possible to match derived <tt class="docutils literal"><span class="pre">ref</span></tt> objects with patterns using <tt class="docutils literal"><span class="pre">of</span></tt> operator. It allows for runtime selection of different derived types.</p>
<p>Note that <tt class="docutils literal"><span class="pre">of</span></tt> operator is necessary for distinguishing between multiple derived objects, or getting fields that are present only in derived types. In addition to it performs <tt class="docutils literal"><span class="pre">isNil()</span></tt> check in the object, so it might be used in cases when you are not dealing with derived types.</p>
<p>Due to <tt class="docutils literal"><span class="pre">isNil()</span></tt> check this pattern only makes sense when working with <tt class="docutils literal"><span class="pre">ref</span></tt> objects.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Base1</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Identifier">First1</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Base1</span>
    <span class="Identifier">first</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
  
  <span class="Identifier">Second1</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Base1</span>
    <span class="Identifier">second</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">let</span> <span class="Identifier">elems</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Base1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span>
  <span class="Identifier">Base1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="DecNumber">123</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
  <span class="Identifier">First1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="DecNumber">456</span><span class="Punctuation">,</span> <span class="Identifier">first</span><span class="Punctuation">:</span> <span class="FloatNumber">0.123</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
  <span class="Identifier">Second1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="DecNumber">678</span><span class="Punctuation">,</span> <span class="Identifier">second</span><span class="Punctuation">:</span> <span class="StringLit">&quot;test&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
  <span class="Keyword">nil</span>
<span class="Punctuation">]</span>

<span class="Keyword">for</span> <span class="Identifier">elem</span> <span class="Keyword">in</span> <span class="Identifier">elems</span><span class="Punctuation">:</span>
  <span class="Keyword">case</span> <span class="Identifier">elem</span><span class="Punctuation">:</span>
    <span class="Keyword">of</span> <span class="Keyword">of</span> <span class="Identifier">First1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">capture1</span><span class="Punctuation">,</span> <span class="Identifier">first</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">first</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
      <span class="Comment"># Only capture `Frist1` elements</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">capture1</span> <span class="Operator">==</span> <span class="DecNumber">456</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">first</span> <span class="Operator">==</span> <span class="FloatNumber">0.123</span>
    
    <span class="Keyword">of</span> <span class="Keyword">of</span> <span class="Identifier">Second1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">capture2</span><span class="Punctuation">,</span> <span class="Identifier">second</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">second</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
      <span class="Comment"># Capture `second` field in derived object</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">capture2</span> <span class="Operator">==</span> <span class="DecNumber">678</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">second</span> <span class="Operator">==</span> <span class="StringLit">&quot;test&quot;</span>
    
    <span class="Keyword">of</span> <span class="Keyword">of</span> <span class="Identifier">Base1</span><span class="Punctuation">(</span><span class="Identifier">fld</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">default</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
      <span class="Comment"># Match all *non-nil* base elements</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">default</span> <span class="Operator">==</span> <span class="DecNumber">123</span>
    
    <span class="Keyword">else</span><span class="Punctuation">:</span>
      <span class="Identifier">doAssert</span> <span class="Identifier">isNil</span><span class="Punctuation">(</span><span class="Identifier">elem</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="matching-different-things-kvminuspairs-matching" href="#matching-different-things-kvminuspairs-matching">KV-pairs matching</a></h2><p>Input json string</p>
<pre class="listing">{&quot;menu&quot;: {
  &quot;id&quot;: &quot;file&quot;,
  &quot;value&quot;: &quot;File&quot;,
  &quot;popup&quot;: {
    &quot;menuitem&quot;: [
      {&quot;value&quot;: &quot;New&quot;, &quot;onclick&quot;: &quot;CreateNewDoc()&quot;},
      {&quot;value&quot;: &quot;Open&quot;, &quot;onclick&quot;: &quot;OpenDoc()&quot;},
      {&quot;value&quot;: &quot;Close&quot;, &quot;onclick&quot;: &quot;CloseDoc()&quot;}
    ]
  }
}}</pre><ul class="simple"><li>Get input <tt class="docutils literal"><span class="pre">[&quot;menu&quot;][&quot;file&quot;]</span></tt> from node and</li>
</ul>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">inj</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">{</span><span class="StringLit">&quot;menu&quot;</span> <span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="StringLit">&quot;file&quot;</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">file</span> <span class="Keyword">is</span> <span class="Identifier">JString</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Comment"># ...</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">raiseAssert</span><span class="Punctuation">(</span><span class="StringLit">&quot;Expected [menu][file] as string, but found &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">inj</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="matching-different-things-option-matching" href="#matching-different-things-option-matching">Option matching</a></h2><p><tt class="docutils literal"><span class="pre">Some(@x)</span></tt> and <tt class="docutils literal"><span class="pre">None()</span></tt> is a special case that will be rewritten into <tt class="docutils literal"><span class="pre">(isSome: true, get: @x)</span></tt> and <tt class="docutils literal"><span class="pre">(isNone: true)</span></tt> respectively. This is made to allow better integration with optional types.  <a class="reference internal" href="#9">9</a>_ .</p>
<p>Note: implementation does not explicitly require to use <tt class="docutils literal"><span class="pre">std/options.Option</span></tt> type, but instead works with anything that provides following functions:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">isSome(): bool</span></tt> (for <tt class="docutils literal"><span class="pre"><span class="Identifier">Some</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> pattern check),</li>
<li><tt class="docutils literal"><span class="pre">isNone(): bool</span></tt> (for <tt class="docutils literal"><span class="pre"><span class="Identifier">None</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> pattern), and</li>
<li><tt class="docutils literal"><span class="pre">get(): T</span></tt> (for getting value if type is some).</li>
</ul>

<h1><a class="toc-backref" id="tree-matching" href="#tree-matching">Tree matching</a></h1><p>For deeply nested AST structures it might be really inconvenient to write one-line expression with lots of <tt class="docutils literal"><span class="pre">ProcDef[@name is Ident() | Postfix[_, @name is Ident()]]</span></tt> and so on. But it is possible to use block syntax for patterns if necessary -</p>
<pre class="listing"><span class="Identifier">ProcDef</span><span class="Punctuation">:</span>
  <span class="Operator">@</span><span class="Identifier">name</span> <span class="Keyword">is</span> <span class="Identifier">Ident</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">|</span> <span class="Identifier">Postfix</span><span class="Punctuation">[</span><span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Operator">@</span><span class="Identifier">name</span> <span class="Keyword">is</span> <span class="Identifier">Ident</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span>
  <span class="Comment"># Other pattern parts</span></pre><p>In case of <tt class="docutils literal"><span class="pre">ProcDef:</span></tt> pattern braces can be omitted because it is clear that we are trying to match a case object here.</p>
<p>Tree matching syntax has a nice property of being extremely close (copy-pastable) from <tt class="docutils literal"><span class="pre">treeRepr</span></tt> for <tt class="docutils literal"><span class="pre">NimNode</span></tt>. For a following proc declaration:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">testProc1</span><span class="Punctuation">(</span><span class="Identifier">arg1</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unpackProc</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span></pre><p>We have an ast</p>
<pre class="listing">ProcDef
  Ident &quot;testProc1&quot;
  Empty
  Empty
  FormalParams
    Empty
    IdentDefs
      Ident &quot;arg1&quot;
      Ident &quot;int&quot;
      Empty
  Empty
  Empty
  StmtList
    DiscardStmt
      Empty</pre><p>That can be matched using following pattern:</p>
<pre class="listing"><span class="Identifier">procDecl</span><span class="Operator">.</span><span class="Identifier">assertMatch</span><span class="Punctuation">:</span>
  <span class="Identifier">ProcDef</span><span class="Punctuation">:</span>
    <span class="Identifier">Ident</span><span class="Punctuation">(</span><span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">name</span><span class="Punctuation">)</span> <span class="Operator">|</span> <span class="Identifier">Postfix</span><span class="Punctuation">[</span><span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">Ident</span><span class="Punctuation">(</span><span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">name</span><span class="Punctuation">)</span><span class="Punctuation">]</span>
    <span class="Identifier">_</span> <span class="Comment"># Term rewriting template</span>
    <span class="Identifier">_</span> <span class="Comment"># Generic params</span>
    <span class="Identifier">FormalParams</span><span class="Punctuation">:</span>
      <span class="Operator">@</span><span class="Identifier">returnType</span>
      <span class="Identifier">all</span> <span class="Identifier">IdentDefs</span><span class="Punctuation">[</span><span class="Operator">@</span><span class="Identifier">trailArgsName</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">]</span>
    
    <span class="Operator">@</span><span class="Identifier">pragmas</span>
    <span class="Identifier">_</span> <span class="Comment"># Reserved</span>
    <span class="Operator">@</span><span class="Identifier">implementation</span></pre>
<h1><a class="toc-backref" id="tree-construction" href="#tree-construction">Tree construction</a></h1><p><tt class="docutils literal"><span class="pre">makeTree</span></tt> provides 'reversed' implementation of pattern matching, which allows to <em>construct</em> tree from pattern, using variables. Example of use</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">HtmlNodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">htmlBase</span> <span class="Operator">=</span> <span class="StringLit">&quot;base&quot;</span>
    <span class="Identifier">htmlHead</span> <span class="Operator">=</span> <span class="StringLit">&quot;head&quot;</span>
    <span class="Identifier">htmlLink</span> <span class="Operator">=</span> <span class="StringLit">&quot;link&quot;</span>
  
  <span class="Identifier">HtmlNode</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">kind</span><span class="Operator">*:</span> <span class="Identifier">HtmlNodeKind</span>
    <span class="Identifier">text</span><span class="Operator">*:</span> <span class="Identifier">string</span>
    <span class="Identifier">subn</span><span class="Operator">*:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">HtmlNode</span><span class="Punctuation">]</span>

<span class="Keyword">func</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">subn</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span>

<span class="Keyword">discard</span> <span class="Identifier">makeTree</span><span class="Punctuation">(</span><span class="Identifier">HtmlNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">base</span><span class="Punctuation">:</span>
    <span class="Identifier">link</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">:</span> <span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span></pre><p>In order to construct tree, <tt class="docutils literal"><span class="pre">kind=</span></tt> and <tt class="docutils literal"><span class="pre">add</span></tt> have to be defined. Internally DSL just creats resulting object, sets <tt class="docutils literal"><span class="pre">kind=</span></tt> and then repeatedly <tt class="docutils literal"><span class="pre">add</span></tt> elements to it. In order to properties for objects either the field has to be exported, or <tt class="docutils literal"><span class="pre">fld=</span></tt> has to be defined (where <tt class="docutils literal"><span class="pre">fld</span></tt> is the name of property you want to set). </p>
</p>
    <div class="section" id="7">
  <h1><a class="toc-backref" href="#7">Types</a></h1>
  <dl class="item">
    <div id="FieldIndex">
  <dt><pre><a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a> <span class="Other">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="ItemMatchKind">
  <dt><pre><a href="matching.html#ItemMatchKind"><span class="Identifier">ItemMatchKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">imkInfixEq</span><span class="Other">,</span>               <span class="Comment">## Match item using infix operator</span>
  <span class="Identifier">imkSubPattern</span><span class="Other">,</span>            <span class="Comment">## Match item by checking it agains subpattern</span>
  <span class="Identifier">imkPredicate</span>               <span class="Comment">## Execute custom predicate to determine if element</span>
                             <span class="Comment">## matches pattern.</span></pre></dt>
  <dd>
    
    Type of item pattern match
    
  </dd>
</div>
<div id="KVPair">
  <dt><pre><a href="matching.html#KVPair"><span class="Identifier">KVPair</span></a> <span class="Other">=</span> <span class="Keyword">object</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="Match">
  <dt><pre><a href="matching.html#Match"><span class="Identifier">Match</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
  <span class="Identifier">bindVar</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span>  <span class="Comment">## Bound variable (if any)</span>
  <span class="Identifier">declNode</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>         <span class="Comment">## Original declaration of match</span>
  <span class="Identifier">isOptional</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
  <span class="Identifier">fallback</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span> <span class="Comment">## Default value in case match fails</span>
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#MatchKind"><span class="Identifier">MatchKind</span></a>
  <span class="Keyword">of</span> <span class="Identifier">kItem</span><span class="Other">:</span>
    <span class="Keyword">case</span>
    <span class="Keyword">of</span> <span class="Identifier">imkInfixEq</span><span class="Other">:</span>
      <span class="Identifier">infix</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>         <span class="Comment">## Infix operator used for comparison</span>
      <span class="Identifier">rhsNode</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>      <span class="Comment">## Rhs expression to compare against</span>
      <span class="Identifier">isPlaceholder</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>   <span class="Comment">## Always true? `_` pattern is an</span>
                             <span class="Comment">## infix expression with `isPlaceholder` equal to true</span>
    <span class="Keyword">of</span> <span class="Identifier">imkSubPattern</span><span class="Other">:</span>
      <span class="Identifier">rhsPattern</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a>     <span class="Comment">## SubPattern to compare value against</span>
    <span class="Keyword">of</span> <span class="Identifier">imkPredicate</span><span class="Other">:</span>
      <span class="Identifier">isCall</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>          <span class="Comment">## Predicate is a call expression</span>
                             <span class="Comment">## (`@val.matches()`) or a free-standing expression</span>
                             <span class="Comment">## (`@val(it.len &lt; 100)`)</span>
      <span class="Identifier">predBody</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>     <span class="Comment">## Body of the expression</span>
  <span class="Keyword">of</span> <span class="Identifier">kAlt</span><span class="Other">:</span>
    <span class="Identifier">altElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Alternatives for matching</span>
  <span class="Keyword">of</span> <span class="Identifier">kSeq</span><span class="Other">:</span>
    <span class="Identifier">seqElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#SeqStructure"><span class="Identifier">SeqStructure</span></a><span class="Other">]</span> <span class="Comment">## Sequence subpatterns</span>
  <span class="Keyword">of</span> <span class="Identifier">kTuple</span><span class="Other">:</span>
    <span class="Identifier">tupleElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Tuple elements</span>
  <span class="Keyword">of</span> <span class="Identifier">kPairs</span><span class="Other">:</span>
    <span class="Identifier">pairElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#KVPair"><span class="Identifier">KVPair</span></a><span class="Other">]</span>
    <span class="Identifier">nocheck</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
  <span class="Keyword">of</span> <span class="Identifier">kSet</span><span class="Other">:</span>
    <span class="Identifier">setElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span>
  <span class="Keyword">of</span> <span class="Identifier">kObject</span><span class="Other">:</span>
    <span class="Identifier">kindCall</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span> <span class="Comment">## Optional node with kind</span>
                               <span class="Comment">## expression pattern (see `hasKind`)</span>
    <span class="Identifier">isRefKind</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">fieldElements</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">pattern</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span><span class="Other">]</span>
    <span class="Identifier">kvMatches</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Optional key-value matches for</span>
                              <span class="Comment">## expressions like `JObject({&quot;key&quot;: @val})`</span>
    <span class="Identifier">seqMatches</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Optional indexed matches for</span>
                               <span class="Comment">## subelement access using `Infix([@op, @lhs, @rhs])` pattern.</span></pre></dt>
  <dd>
    
    Object describing single match for element
    
  </dd>
</div>
<div id="MatchError">
  <dt><pre><a href="matching.html#MatchError"><span class="Identifier">MatchError</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">CatchableError</span></pre></dt>
  <dd>
    
    Exception indicating match failure
    
  </dd>
</div>
<div id="MatchKind">
  <dt><pre><a href="matching.html#MatchKind"><span class="Identifier">MatchKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">kItem</span><span class="Other">,</span>                    <span class="Comment">## Match single element</span>
  <span class="Identifier">kSeq</span><span class="Other">,</span>                     <span class="Comment">## Match sequence of elements</span>
  <span class="Identifier">kTuple</span><span class="Other">,</span>                   <span class="Comment">## Mach tuple (anonymous or named)</span>
  <span class="Identifier">kPairs</span><span class="Other">,</span>                   <span class="Comment">## Match key-value pairs</span>
  <span class="Identifier">kObject</span><span class="Other">,</span>                  <span class="Comment">## Match object, named tuple or object-like value</span>
  <span class="Identifier">kSet</span><span class="Other">,</span>                     <span class="Comment">## Match set of elements</span>
  <span class="Identifier">kAlt</span>                       <span class="Comment">## Ordered choice - mactch any of patterns.</span></pre></dt>
  <dd>
    
    Different kinds of matching patterns
    
  </dd>
</div>
<div id="SeqKeyword">
  <dt><pre><a href="matching.html#SeqKeyword"><span class="Identifier">SeqKeyword</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">lkAny</span> <span class="Other">=</span> <span class="StringLit">&quot;any&quot;</span><span class="Other">,</span>            <span class="Comment">## Any element from seq</span>
  <span class="Identifier">lkAll</span> <span class="Other">=</span> <span class="StringLit">&quot;all&quot;</span><span class="Other">,</span>            <span class="Comment">## All elements from seq</span>
  <span class="Identifier">lkNone</span> <span class="Other">=</span> <span class="StringLit">&quot;none&quot;</span><span class="Other">,</span>          <span class="Comment">## None of the elements from seq</span>
  <span class="Identifier">lkOpt</span> <span class="Other">=</span> <span class="StringLit">&quot;opt&quot;</span><span class="Other">,</span>            <span class="Comment">## Optionaly match element in seq</span>
  <span class="Identifier">lkUntil</span> <span class="Other">=</span> <span class="StringLit">&quot;until&quot;</span><span class="Other">,</span>        <span class="Comment">## All elements until</span>
  <span class="Identifier">lkPref</span> <span class="Other">=</span> <span class="StringLit">&quot;pref&quot;</span><span class="Other">,</span>          <span class="Comment">## All elements while</span>
  <span class="Identifier">lkPos</span><span class="Other">,</span>                    <span class="Comment">## Exact position</span>
  <span class="Identifier">lkSlice</span><span class="Other">,</span>                  <span class="Comment">## Subrange slice</span>
  <span class="Identifier">lkTrail</span>                    <span class="Comment">## Variadic placeholder `.._`</span></pre></dt>
  <dd>
    
    Possible special words for seq pattern matching
    
  </dd>
</div>
<div id="SeqStructure">
  <dt><pre><a href="matching.html#SeqStructure"><span class="Identifier">SeqStructure</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Comment">## Original declaration of the node</span>
  <span class="Identifier">bindVar</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span>  <span class="Comment">## Optional bound variable</span>
  <span class="Identifier">pattern</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a>            <span class="Comment">## Patterh for element matching</span>
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#SeqKeyword"><span class="Identifier">SeqKeyword</span></a>
  <span class="Keyword">of</span> <span class="Identifier">lkSlice</span><span class="Other">:</span>
    <span class="Identifier">slice</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>
  <span class="Keyword">else</span><span class="Other">:</span>
    <span class="Keyword">nil</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="VarKind">
  <dt><pre><a href="matching.html#VarKind"><span class="Identifier">VarKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">vkRegular</span><span class="Other">,</span>                <span class="Comment">## Regular variable, assigned once</span>
  <span class="Identifier">vkSequence</span><span class="Other">,</span> <span class="Identifier">vkOption</span><span class="Other">,</span> <span class="Identifier">vkSet</span><span class="Other">,</span> <span class="Identifier">vkAlt</span></pre></dt>
  <dd>
    
    Kind of matched variables
    
  </dd>
</div>
<div id="VarSpec">
  <dt><pre><a href="matching.html#VarSpec"><span class="Identifier">VarSpec</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">decl</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>             <span class="Comment">## First time variable has been declared</span>
  <span class="Keyword">case</span> <span class="Identifier">varKind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#VarKind"><span class="Identifier">VarKind</span></a>     <span class="Comment">## Type of the variable</span>
  <span class="Keyword">of</span> <span class="Identifier">vkAlt</span><span class="Other">:</span>
    <span class="Identifier">prefixMap</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">Path</span><span class="Other">,</span> <span class="Identifier">AltSpec</span><span class="Other">]</span>
  <span class="Keyword">else</span><span class="Other">:</span>
    <span class="Keyword">nil</span>
  <span class="Identifier">typePath</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Path</span>            <span class="Comment">## Whole path for expression that can be used to</span>
                             <span class="Comment">## determine type of the variable.</span>
  <span class="Identifier">foundCount</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">int</span>           <span class="Comment">## Number of variable occurencies in expression</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

  </dl>
</div>
<div class="section" id="10">
  <h1><a class="toc-backref" href="#10">Consts</a></h1>
  <dl class="item">
    <div id="nnkFloatKinds">
  <dt><pre><a href="matching.html#nnkFloatKinds"><span class="Identifier">nnkFloatKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkFloatLit</span><span class="Other">..</span><span class="DecNumber">nnkFloat128Lit</span><span class="Other">}</span></pre></dt>
  <dd>
    
    Set of all nim node kinds for float literal nodes
    
  </dd>
</div>
<div id="nnkIdentKinds">
  <dt><pre><a href="matching.html#nnkIdentKinds"><span class="Identifier">nnkIdentKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkIdent</span><span class="Other">,</span> <span class="DecNumber">nnkSym</span><span class="Other">,</span> <span class="DecNumber">nnkOpenSymChoice</span><span class="Other">}</span></pre></dt>
  <dd>
    
    Set of all nim node kinds for identifier-like nodes
    
  </dd>
</div>
<div id="nnkIntKinds">
  <dt><pre><a href="matching.html#nnkIntKinds"><span class="Identifier">nnkIntKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkCharLit</span><span class="Other">..</span><span class="DecNumber">nnkUInt64Lit</span><span class="Other">}</span></pre></dt>
  <dd>
    
    Set of all nim node kinds for integer literal nodes
    
  </dd>
</div>
<div id="nnkStrKinds">
  <dt><pre><a href="matching.html#nnkStrKinds"><span class="Identifier">nnkStrKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkStrLit</span><span class="Other">..</span><span class="DecNumber">nnkTripleStrLit</span><span class="Other">}</span></pre></dt>
  <dd>
    
    Set of all nim node kinds for string nodes
    
  </dd>
</div>
<div id="nnkTokenKinds">
  <dt><pre><a href="matching.html#nnkTokenKinds"><span class="Identifier">nnkTokenKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkEmpty</span><span class="Other">..</span><span class="DecNumber">nnkSym</span><span class="Other">,</span> <span class="DecNumber">nnkCharLit</span><span class="Other">..</span><span class="DecNumber">nnkTripleStrLit</span><span class="Other">,</span> <span class="DecNumber">nnkOpenSymChoice</span><span class="Other">}</span></pre></dt>
  <dd>
    
    Set of all token-like nodes (primitive type literals or identifiers)
    
  </dd>
</div>

  </dl>
</div>
<div class="section" id="12">
  <h1><a class="toc-backref" href="#12">Procs</a></h1>
  <dl class="item">
    <div id="$-procs-all">
  <div id="$,KVPair">
  <dt><pre><span class="Keyword">func</span> <a href="#%24%2CKVPair"><span class="Identifier">`$`</span></a><span class="Other">(</span><span class="Identifier">kvp</span><span class="Other">:</span> <a href="matching.html#KVPair"><span class="Identifier">KVPair</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span>
                                <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="$,Match">
  <dt><pre><span class="Keyword">func</span> <a href="#%24%2CMatch"><span class="Identifier">`$`</span></a><span class="Other">(</span><span class="Identifier">match</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span>
                                 <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="$,Path">
  <dt><pre><span class="Keyword">func</span> <a href="#%24%2CPath"><span class="Identifier">`$`</span></a><span class="Other">(</span><span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">Path</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="$,SeqStructure">
  <dt><pre><span class="Keyword">func</span> <a href="#%24%2CSeqStructure"><span class="Identifier">`$`</span></a><span class="Other">(</span><span class="Identifier">ss</span><span class="Other">:</span> <a href="matching.html#SeqStructure"><span class="Identifier">SeqStructure</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span>
                                     <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="==-procs-all">
  <div id="==,FieldIndex,SomeInteger">
  <dt><pre><span class="Keyword">func</span> <a href="#%3D%3D%2CFieldIndex%2CSomeInteger"><span class="Identifier">`==`</span></a><span class="Other">(</span><span class="Identifier">idx</span><span class="Other">:</span> <a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">SomeInteger</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="getKindNames-procs-all">
  <div id="getKindNames,NimNode">
  <dt><pre><span class="Keyword">proc</span> <a href="#getKindNames%2CNimNode"><span class="Identifier">getKindNames</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">KeyError</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="kind=-procs-all">
  <div id="kind=,NimNode,NimNodeKind">
  <dt><pre><span class="Keyword">func</span> <a href="#kind%3D%2CNimNode%2CNimNodeKind"><span class="Identifier">kind=</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">NimNodeKind</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="makeMatchExpr-procs-all">
  <div id="makeMatchExpr,Match,NimNode,bool,NimNode">
  <dt><pre><span class="Keyword">func</span> <a href="#makeMatchExpr%2CMatch%2CNimNode%2Cbool%2CNimNode"><span class="Identifier">makeMatchExpr</span></a><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">;</span> <span class="Identifier">mainExpr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">doRaise</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span>
                   <span class="Identifier">originalMainExpr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">expr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">,</span>
    <span class="Identifier">vtable</span><span class="Other">:</span> <span class="Identifier">VarTable</span><span class="Other">,</span> <span class="Identifier">mixident</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">KeyError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Create NimNode for checking whether or not item referred to by <tt class="docutils literal"><span class="pre"><span class="Identifier">mainExpr</span></span></tt> matches pattern described by <tt class="docutils literal"><span class="pre"><span class="Identifier">Match</span></span></tt>
    
  </dd>
</div>

</div>
<div id="parseMatchExpr-procs-all">
  <div id="parseMatchExpr,NimNode">
  <dt><pre><span class="Keyword">func</span> <a href="#parseMatchExpr%2CNimNode"><span class="Identifier">parseMatchExpr</span></a><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="str-procs-all">
  <div id="str,NimNode">
  <dt><pre><span class="Keyword">func</span> <a href="#str%2CNimNode"><span class="Identifier">str</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="str=-procs-all">
  <div id="str=,NimNode,string">
  <dt><pre><span class="Keyword">func</span> <a href="#str%3D%2CNimNode%2Cstring"><span class="Identifier">str=</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">val</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="toAccs-procs-all">
  <div id="toAccs,Path,NimNode,bool">
  <dt><pre><span class="Keyword">func</span> <a href="#toAccs%2CPath%2CNimNode%2Cbool"><span class="Identifier">toAccs</span></a><span class="Other">(</span><span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">Path</span><span class="Other">;</span> <span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">pathForType</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">NimNode</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Convert path in object to expression for getting element at path.
    
  </dd>
</div>

</div>

  </dl>
</div>
<div class="section" id="17">
  <h1><a class="toc-backref" href="#17">Macros</a></h1>
  <dl class="item">
    <div id="assertMatch-macros-all">
  <div id="assertMatch.m,untyped,untyped">
  <dt><pre><span class="Keyword">macro</span> <a href="#assertMatch.m%2Cuntyped%2Cuntyped"><span class="Identifier">assertMatch</span></a><span class="Other">(</span><span class="Identifier">input</span><span class="Other">,</span> <span class="Identifier">pattern</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Try to match <tt class="docutils literal"><span class="pre"><span class="Identifier">input</span></span></tt> using <tt class="docutils literal"><span class="pre"><span class="Identifier">pattern</span></span></tt> and raise <tt class="docutils literal"><span class="pre"><span class="Identifier">MatchError</span></span></tt> on failure. For DSL syntax details see start of the document.
    
  </dd>
</div>

</div>
<div id="case-macros-all">
  <div id="case.m,untyped">
  <dt><pre><span class="Keyword">macro</span> <a href="#case.m%2Cuntyped"><span class="Identifier">`case`</span></a><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="expand-macros-all">
  <div id="expand.m,typed">
  <dt><pre><span class="Keyword">macro</span> <a href="#expand.m%2Ctyped"><span class="Identifier">expand</span></a><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="hasKindImpl-macros-all">
  <div id="hasKindImpl.m,typed,untyped">
  <dt><pre><span class="Keyword">macro</span> <a href="#hasKindImpl.m%2Ctyped%2Cuntyped"><span class="Identifier">hasKindImpl</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="matches-macros-all">
  <div id="matches.m,untyped,untyped">
  <dt><pre><span class="Keyword">macro</span> <a href="#matches.m%2Cuntyped%2Cuntyped"><span class="Identifier">matches</span></a><span class="Other">(</span><span class="Identifier">input</span><span class="Other">,</span> <span class="Identifier">pattern</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Try to match <tt class="docutils literal"><span class="pre"><span class="Identifier">input</span></span></tt> using <tt class="docutils literal"><span class="pre"><span class="Identifier">pattern</span></span></tt> and return <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt> on failure. For DSL syntax details see start of the document.
    
  </dd>
</div>

</div>

  </dl>
</div>
<div class="section" id="18">
  <h1><a class="toc-backref" href="#18">Templates</a></h1>
  <dl class="item">
    <div id=":=-templates-all">
  <div id=":=.t,untyped,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#%3A%3D.t%2Cuntyped%2Cuntyped"><span class="Identifier">`:=`</span></a><span class="Other">(</span><span class="Identifier">lhs</span><span class="Other">,</span> <span class="Identifier">rhs</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Shorthand for <tt class="docutils literal"><span class="pre"><span class="Identifier">assertMatch</span></span></tt>
    
  </dd>
</div>

</div>
<div id="?=-templates-all">
  <div id="?=.t,untyped,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#%3F%3D.t%2Cuntyped%2Cuntyped"><span class="Identifier">`?=`</span></a><span class="Other">(</span><span class="Identifier">lhs</span><span class="Other">,</span> <span class="Identifier">rhs</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Shorthand for <tt class="docutils literal"><span class="pre"><span class="Identifier">matches</span></span></tt>
    
  </dd>
</div>

</div>
<div id="[]-templates-all">
  <div id="[].t,,static[FieldIndex]">
  <dt><pre><span class="Keyword">template</span> <a href="#%5B%5D.t%2C%2Cstatic%5BFieldIndex%5D"><span class="Identifier">`[]`</span></a><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">tuple</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">static</span><span class="Other">[</span><a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="hasKind-templates-all">
  <div id="hasKind.t,untyped,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#hasKind.t%2Cuntyped%2Cuntyped"><span class="Identifier">hasKind</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">,</span> <span class="Identifier">kindExpr</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Determine if <tt class="docutils literal"><span class="pre"><span class="Identifier">head</span></span></tt> has <tt class="docutils literal"><span class="pre"><span class="Identifier">kind</span></span></tt> value. Either function/procedure <tt class="docutils literal"><span class="pre"><span class="Identifier">kind</span></span></tt> or field with the same name is expected to be declared. Type of <tt class="docutils literal"><span class="pre"><span class="Identifier">kind</span></span></tt> must be an enum. Kind expression is a pattern describing expected values. Possible examples of pattern (assuming value of type <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt> is used as <tt class="docutils literal"><span class="pre"><span class="Identifier">head</span></span></tt>)<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">nnkIntLit</span></span></tt> - match integer literal</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">IntLit</span></span></tt> - alternative (preferred) syntax for matching enum values <tt class="docutils literal"><span class="pre"><span class="Identifier">nnk</span></span></tt> prefix can be omitted.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="makeTree-templates-all">
  <div id="makeTree.t,typed,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#makeTree.t%2Ctyped%2Cuntyped"><span class="Identifier">makeTree</span></a><span class="Other">(</span><span class="Identifier">T</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">pattern</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Construct tree from pattern matching expression. For example of use see documentation at the start of the module
    
  </dd>
</div>

</div>
<div id="varOfIteration-templates-all">
  <div id="varOfIteration.t,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#varOfIteration.t%2Cuntyped"><span class="Identifier">varOfIteration</span></a><span class="Other">(</span><span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>

  </dl>
</div>

  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-03-05 09:50:19 UTC</small>
      </div>
    </div>
  </div>
  
  <!-- Google fonts -->
  <link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>
</body>
</html>
